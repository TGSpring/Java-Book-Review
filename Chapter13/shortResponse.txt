Tyler Spring
9/3/2024
Chapter 13 short response questions

Section 13.1 

Question 1: Describe two ways to search an unsorted array of String objects using the Java class libraries:
        - Way 1 is do a manual linear search using compareTo. Since String implements Comparable<String>, you can 
        loop through the array and check. You use compareTo form the Java library. It works on unsorted arrays because 
        you're just scanning everything.
        - Way 2 is to use the utility classes of Arrays and Collections. Even though the array is unsorted, you can still 
        turn it into a library-supported structure and search. With Arrays.asList(arr).contains(target), wraps the array in a List 
        and uses .equals() internally. Or Arrays.asList(arr).indexOf(target) to get the index.
        - .equals() is best for when you just want to know are they equal, .compareTo() is best when you care about ordering or want 
        to stay within the Comparable framework.

Question 3: Should you use a sequential or binary search on an array of Point objects, and why?
        - A sequential search works on any array whether it is sorted or not. It just walks through the elements one by one
        and checks if any match. A binary search requires the array to be sorted and jumps to the middle, checks, eliminates 
        half of the possibilities each step. It also needs a way to compare objects, like Comparable or a Comparator.
        - A Point class usually does not implement a Comparable, so Java does not know how to order two points. That means you 
        can't just sort them and use binarySearch unless you first define a comparison rule.
        - If the array is unsorted, or if you have not defined a natural ordering for the Point objects, you have to use 
        sequential search. If you define an ordering and sort the array, then you can use binary search for faster lookups.

Section 13.2 

Question 14: Determine the complexity classes of the algorithms that could be used to perform the following task:
                - Finding the average of the numbers in an array of integers.
                        To compute an averages, you need the sum of all the elements.
                        That requires visiting every element once.
                        No shortcut exists.
                        After summing, you divide by n, which is O(1).
                                Complexity: O(n), linear scan, must touch every element.

                - Finding the closet distance between any pair of points in an array of points.
                        Every pair of points needs a distance calculation.
                        Number of pairs in n items = (n 2) = (n(n-1)/2).
                        That grows like n^2.
                                Complexity: O(n^2), pairwise comparisons always lead to quadratic growth.

                - Finding the maximum value in an array of real numbers.
                        Worst case: max is the last element.
                        Must compare each element at least once.
                        That's one pass, O(n).
                                Complexity: O(n), Can't stop early, max might be at the end.

                - Counting the median length of the Strings in an array.
                        To find the median, you need order.
                        Easiest way: sort by length. Sorting comparison-based arrays = O(n log n).
                        After sorting, grabbing the middle = O(1).
                                Complexity: O(n log n), median usually implies sorting. Sorting dominates cost.
                
                - Raising an integer to a power - for example, A^B.
                        Naive multiply A by itself B times -> O(B).
                        Better: exponentiation by squaring.
                        If B is even, A^B = (A^(B/2))^2.
                        If B is odd, A^B = A * A^(B - 1).
                        This halves B at each step -> logarithmic.
                                Complexity: O(log B), divide exponent in half each step instead of subtracting 1.
                
                - Examining an array of Points to see how trios of points are colinear -- that is, 
                how many groups of three points could be connected by a straight line.
                        You need to check every trio of points.
                        Number of trios = (n 3) = (n(n - 1)(n - 2)) / 6.
                        This grows like n^3.
                                Complexity: O(n^3), when problem says triplets, think of cubic time.

                - Counting the number of lines in a file.
                        Must check each line once.
                        For n lines, that's n steps.
                        No shortcut: can't skip lines without missing counts.
                                Complexity: O(n), One unit of work per line -> linear time.

                - Determining whether a given integer representing a year stores a leap year. Divisible by 4, but not 
                divisible by 100 unless also divisible by 400.
                        Rules: Divisible by 4, but not 100 unless divisible by 400.
                        That's just 3 modulus operations.
                        Always the same number of steps, no matter the year's size.
                                Complexity: O(1), Fixed number of operations = constant time.

                /////// THIS IS A NOTE FOR ME TO REMEMBER: I STRUGGLE WITH COMPLEXITIES IGNORE.. OR READ IF YOU WANT ////////
                        1. Average of an array O(n)
                                You can't average without seeing every number.

                        2. Closet pair of points O(n^2)
                                Pairs = quadratic. Every point shakes hands with every point.

                        3. Maximum in array O(n)
                                Max might be at the end, so you check them all.

                        4. Median string length O(n log n)
                                Median needs sorting. Sorting is the price of order.

                        5. Exponentiation (A^B) -> O(log B)
                                Cut the exponent in half each step: log speedup.

                        6. Colinear Triplets O(n^3)
                                Triplets = cubic. Choose three, check all.

                        7. Count file lines O(n)
                                One step per line. Read to count.

                        8. Leap year check O(1)
                                Fixed math rules, constant time. 
Section 13.3

Question 16: What is the runtime complexity class of a sequential search on an unsorted array? What is the
                runtime complexity class of the modified sequential search on a sorted array?

                - Unsorted: This search starts at index 0, checking each element one by one until you find the 
                target or reach the end. In the worst case the element is at the very end or isn’t in the array, 
                so you must visit every element. This gives a runtime complexity of O(n) (linear), because you can’t 
                make any decisions to stop early.

                - Sorted: The difference here is that since the array is sorted, we can stop early if we reach an element 
                greater than the target, since no later element can match. In the best case, the algorithm might stop almost 
                immediately (runtime O(1)). In the worst case, the target is larger than all elements or not present, which 
                still requires scanning the entire array (O(n)). Overall, the runtime class remains O(n), but the sorted version
                can sometimes terminate earlier in practice.

Question 23: What modifications would you have to make to the selectionSort method to cause it to sort an array of double values
                rather than one of integer values? 

                - SelectionSort works by scanning an array to find the smallest element in an unsorted array. Normally written 
                int[]. When changing it to double the same logic works for comparisons. The only changes are its declaration 
                double[] and comparison libraries from Integer.compare() to Double.compare(). Unless it is just a simple < comparison.

Section 13.4

Question 26: How many calls on the mergeSort method are generated by a call to sort a list of length 32?

                - MergeSort is a divide-and-conquer algorithm: each call splits the array in halves, then recursively 
                sorts each half. Each recursive call creates two more calls for it two halves, until the base case, length 1,
                is reached. For a list of n = 32 the recursion forms a binary tree. Think about the number of nodes in a full 
                binary tree with 32 leaves. Each split creates 2 more calls. This keeps doubling until the leaves are length 1.
                The sum of these calls is 1 + 2 + 4 + 8 + 16 + 32 = 64 calls.